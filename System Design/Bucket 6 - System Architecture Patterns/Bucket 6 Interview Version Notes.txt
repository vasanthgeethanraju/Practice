6.1 Web Sockets (Interview version)

"WebSockets provide a persistent, full-duplex communication channel between client and server over a single TCP connection, allowing both sides to send messages anytime without repeated HTTP requests. Unlike REST, where clients must poll for updates, WebSockets enable real-time server push, making them ideal for bidirectional systems like chat applications, trading dashboards, live collaboration tools, and location tracking. In production systems, clients first establish a normal HTTP connection which upgrades to a WebSocket, after which the connection remains open and is maintained using heartbeat ping/pong mechanisms to detect network drops. Because WebSockets are stateful, scaling differs from stateless HTTP - load balancers either use sticky sessions or, more commonly, multiple WebSocket servers connected through a pub/sub layer such as Redis or Kafka so events can be broadcast across instances while each server manages only its local connections. Reliability is handled outside WebSockets using databases and message queues, allowing missed events to be replayed when clients reconnect. Event-driven runtimes like Node.js work well here because a single event loop can manage thousands of mostly idle connections efficiently. At scale, systems must also handle slow consumers using backpressure techniques such as rate limiting, batching, dropping stale updates, or disconnecting lagging clients to prevent memory exhaustion. Real-world systems like WhatsApp and Slack use WebSockets for messaging, Bloomberg terminals for live market data fanout, Uber for realtime location updates, and collaborative editors like Google Docs for live synchronization, typically combining REST for CRUD operations with WebSockets for realtime state changes."

6.2 Webhooks (Interview Version)

"A webhook is an event-driven HTTP callback where one service automatically sends a request to another service when a specific event occurs, eliminating the need for polling. Instead of repeatedly checking for updates, the receiving system exposes a webhook endpoint, and the provider system sends a short-lived HTTP POST request with event data whenever something changes. Webhooks are commonly used for server-to-server integrations such as payment confirmations from Stripe, GitHub triggering CI/CD pipelines after a code push, or notification systems reacting to external events. Because delivery can be retried or duplicated, webhook consumers typically implement idempotency, authentication via signatures, and retry handling to ensure reliability."

6.3 Microservices (Interview version)

"Microservices architecture decomposes a large application into small, domain-aligned services (e.g., users, orders, payments, notifications) that are independently deployable and scalable. Each service typically owns its own database (choosing SQL vs NoSQL as needed, with indexing, replication, and sharding decisions made per service) and exposes APIs (often REST) for synchronous request/response flows, while event-driven workflows use message queues/streams (Kafka/Redis) to decouple services, improve reliability, and enable retries. In production, services run as containers orchestrated by Kubernetes, sit behind load balancers, and use cross-cutting controls like authentication, rate limiting, caching, and observability; for realtime features, a dedicated WebSocket gateway layer often pushes updates to clients while durability comes from the DB/queue and reconnect logic. The key benefit is selective horizontal scaling and faster independent deployments with fault isolation, while the tradeoff is distributed-systems complexity - network latency/failures, data consistency across services, and the need for strong monitoring/tracing, idempotency, and well-defined boundaries."

6.4 API Gateways (Interview version)

"An API Gateway acts as the single entry point into a microservices-based system, sitting behind an external load balancer and in front of backend services. Instead of clients directly calling multiple services, the gateway centralizes cross-cutting concerns such as authentication and authorization (JWT/OAuth), rate limiting, request validation, routing, API versioning, logging, and observability. The gateway routes incoming requests to the appropriate microservice using service discovery, typically through Kubernetes services that internally load-balance traffic across horizontally scaled service pods. API gateways themselves are also horizontally scaled for high availability and throughput, with load balancers distributing traffic across gateway instances. They may also aggregate responses from multiple services, expose webhook endpoints for external integrations, and route or terminate WebSocket connections for realtime communication. This design simplifies clients, improves security, and allows backend services to evolve and scale independently while keeping infrastructure concerns centralized."